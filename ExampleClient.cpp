/**
 * ----------------------------------------------------------------------------
 * XboxTLS Example Client
 * ----------------------------------------------------------------------------
 * This is a minimal demonstration of the XboxTLS library running on a 
 * modded Xbox 360. It showcases how to perform a secure TLS 1.2 connection 
 * to a remote server using the BearSSL cryptographic library (embedded into
 * the XboxTLS implementation).
 *
 * ----------------------------------------------------------------------------
 * Features:
 * - Initializes the Xbox 360 network stack (XNet, Winsock).
 * - Resolves a domain name using Xbox 360's DNS (XNetDnsLookup).
 * - Supports TLS 1.2 with both RSA and Elliptic Curve (EC) trust anchors.
 * - Performs a secure TLS handshake and sends an HTTPS GET(POST also supported) request.
 * - Prints the received HTTP response using XboxTLS_Read and debug output.
 *
 * ----------------------------------------------------------------------------
 * Library Dependencies:
 * - XboxTLS (this project's core TLS wrapper).
 * - BearSSL (used internally for TLS 1.2, x.509, ECDSA/RSA, HMAC, etc.).
 *
 * ----------------------------------------------------------------------------
 * Trust Anchor Notes:
 * This client supports two types of root certificate trust anchors:
 *   1. EC (Elliptic Curve) trust anchors — commonly used with modern CAs.
 *   2. RSA trust anchors — still widely used for backwards compatibility.
 *
 * The example provides pre-filled trust anchor values from:
 *   - Google Trust Services GTS Root R4 (EC P-384)
 *   - ISRG Root X1 (RSA 2048 / 65537)
 *
 * ----------------------------------------------------------------------------
 * Usage Notes:
 * - This client is designed for development/testing on modded Xbox 360 units.
 * - Built using the Xbox 360 XDK with support for WinSock and XNet.
 * - This implementation assumes you are targeting TLS 1.2 endpoints.
 *   It does not support TLS 1.3.
 *
 * ----------------------------------------------------------------------------
 * Author: Jakob Rangel
 * License: MIT / Open Source
 */


#include <xtl.h>
#include "XboxTLS.h"
#include <stdio.h>

static const unsigned char EC_DN[] = { // GTS ROOT G4 Cert
	0x30, 0x47, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
	0x02, 0x55, 0x53, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04, 0x0A,
	0x13, 0x19, 0x47, 0x6F, 0x6F, 0x67, 0x6C, 0x65, 0x20, 0x54, 0x72, 0x75,
	0x73, 0x74, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20,
	0x4C, 0x4C, 0x43, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03,
	0x13, 0x0B, 0x47, 0x54, 0x53, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x52,
	0x34
};

static const unsigned char EC_Q[] = { // GTS ROOT G4 Cert
	0x04, 0xF3, 0x74, 0x73, 0xA7, 0x68, 0x8B, 0x60, 0xAE, 0x43, 0xB8, 0x35,
	0xC5, 0x81, 0x30, 0x7B, 0x4B, 0x49, 0x9D, 0xFB, 0xC1, 0x61, 0xCE, 0xE6,
	0xDE, 0x46, 0xBD, 0x6B, 0xD5, 0x61, 0x18, 0x35, 0xAE, 0x40, 0xDD, 0x73,
	0xF7, 0x89, 0x91, 0x30, 0x5A, 0xEB, 0x3C, 0xEE, 0x85, 0x7C, 0xA2, 0x40,
	0x76, 0x3B, 0xA9, 0xC6, 0xB8, 0x47, 0xD8, 0x2A, 0xE7, 0x92, 0x91, 0x6A,
	0x73, 0xE9, 0xB1, 0x72, 0x39, 0x9F, 0x29, 0x9F, 0xA2, 0x98, 0xD3, 0x5F,
	0x5E, 0x58, 0x86, 0x65, 0x0F, 0xA1, 0x84, 0x65, 0x06, 0xD1, 0xDC, 0x8B,
	0xC9, 0xC7, 0x73, 0xC8, 0x8C, 0x6A, 0x2F, 0xE5, 0xC4, 0xAB, 0xD1, 0x1D,
	0x8A
};

const unsigned char RSA_DN[] = {
    0x30, 0x31, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03,
    0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
    0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0A,
    0x13, 0x0A, 0x49, 0x53, 0x52, 0x47, 0x20, 0x2C,
    0x49, 0x6E, 0x63, 0x2E, 0x31, 0x13, 0x30, 0x11,
    0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0A, 0x49,
    0x53, 0x52, 0x47, 0x20, 0x52, 0x6F, 0x6F, 0x74,
    0x20, 0x58, 0x31
};
const unsigned char RSA_N[] = {
    0x00, 0xaf, 0x2f, 0x62, 0xe9, 0xf5, 0x3d, 0x1f, 0x64, 0x2e, 0x98, 0x0f, 0x09, 0x3a, 0x65, 0x9b,
    0xf5, 0x77, 0x6f, 0x47, 0xdc, 0x96, 0xf9, 0x4e, 0x58, 0x91, 0x1f, 0x94, 0xb6, 0x1b, 0x7f, 0x7d,
    0x25, 0xa4, 0x0c, 0xc2, 0x55, 0x43, 0xd6, 0x62, 0xe3, 0xf3, 0x82, 0xc5, 0x0b, 0x12, 0x4d, 0xb0,
    0x0e, 0xb3, 0x4c, 0x4e, 0xf0, 0xac, 0x6a, 0x26, 0x4e, 0xd3, 0x93, 0xf4, 0x39, 0xd2, 0xc8, 0x2c,
    0x3b, 0xc6, 0x0a, 0xc7, 0x57, 0x18, 0x6c, 0xd1, 0x60, 0x60, 0x87, 0xd8, 0xac, 0x00, 0x11, 0x5d,
    0xb3, 0x69, 0x6a, 0x25, 0x80, 0xa5, 0x6f, 0x84, 0x2c, 0x1b, 0x33, 0x61, 0x4a, 0xe7, 0xd1, 0x8d,
    0x1f, 0xa2, 0xb0, 0x0d, 0x2d, 0xea, 0xbb, 0x0e, 0x5f, 0xe2, 0x7f, 0xa5, 0x80, 0xd2, 0x5f, 0xb7,
    0x25, 0x34, 0xb0, 0x4e, 0x76, 0x9e, 0x2c, 0x83, 0x25, 0xb2, 0x3e, 0x33, 0xe7, 0x2d, 0x5e, 0x45,
    0x93, 0xa4, 0xb2, 0x2b, 0x73, 0x1a, 0x6c, 0xf4, 0x30, 0x95, 0x28, 0x3b, 0x6b, 0xa3, 0x75, 0x4d,
    0x38, 0xbe, 0x7a, 0x11, 0x3c, 0xdf, 0x71, 0x33, 0x4f, 0x0e, 0x9e, 0x6d, 0xe5, 0xa6, 0x76, 0x7e,
    0x3e, 0xf6, 0xf4, 0x91, 0x8a, 0xbe, 0x3d, 0xf4, 0x11, 0xc4, 0x91, 0x0a, 0xe3, 0x5c, 0x2f, 0xbe,
    0x2e, 0x27, 0x3e, 0x61, 0x61, 0xb4, 0x12, 0xfa, 0xb9, 0xd4, 0x26, 0x44, 0xbd, 0x1a, 0xd3, 0x12,
    0x68, 0x96, 0xa2, 0x92, 0x7a, 0x8b, 0x86, 0x4d, 0x12, 0x29, 0xa1, 0x77, 0x53, 0x4a, 0x9a, 0x35,
    0xe2, 0xa1, 0x56, 0x45, 0xc5, 0xf3, 0xd7, 0x70, 0xd7, 0x91, 0x9f, 0x8c, 0x1b, 0xdf, 0x1c, 0x0b,
    0xb1, 0x3d, 0xa7, 0xf2, 0xbb, 0xd9, 0x6b, 0x75, 0x8d, 0x2d, 0x7b, 0xc7, 0x19, 0x5b, 0x9f, 0x32,
    0xbc, 0x3a, 0x1a, 0xd5, 0xa3, 0x93, 0xb3, 0xf9, 0x75, 0x26, 0x2e, 0x67, 0xf2, 0x77, 0x93, 0x41
};
const unsigned char RSA_E[] = { 0x01, 0x00, 0x01 };  // 65537





void DumpResponse(XboxTLSContext* ctx) {
    char buffer[2048];
    int r;
    while ((r = XboxTLS_Read(ctx, buffer, sizeof(buffer) - 1)) > 0) {
        buffer[r] = '\0';
        OutputDebugStringA(buffer); // Prints to debugger
    }
}
/**
 * @brief Resolves a domain name to an IPv4 address string.
 * 
 * @param domain The hostname to resolve (e.g., "example.com").
 * @param resolvedIP Output buffer to store the resolved IP address.
 * @param ipBufferSize Size of the resolvedIP buffer.
 * @return true if resolution succeeded, false otherwise.
 */
bool ResolveDNS(const char* domain, char* resolvedIP, int ipBufferSize)
{
    XNDNS* pxndns = nullptr;
    if (XNetDnsLookup(domain, nullptr, &pxndns) != 0)
        return false;

    // Wait up to ~5 seconds for DNS resolution
    for (int i = 0; i < 50 && pxndns->iStatus == WSAEINPROGRESS; ++i)
        Sleep(100);

    if (pxndns->iStatus != 0 || pxndns->cina == 0) {
        XNetDnsRelease(pxndns);
        return false;
    }

    XNetInAddrToString(pxndns->aina[0], resolvedIP, ipBufferSize);
    XNetDnsRelease(pxndns);
    return true;
}

bool RunTLSClient() {
    // Step 1: Network stack setup
    XNetStartupParams xnsp = { 0 };
    xnsp.cfgSizeOfStruct = sizeof(xnsp);
    xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
    if (XNetStartup(&xnsp) != 0)
        return false;

    WSADATA wsadata;
    if (WSAStartup(MAKEWORD(2, 2), &wsadata) != 0)
        return false;

    Sleep(6000); // Give time for DHCP to settle, could probably lower this, but never tried.

    // Step 2: Create TLS context
    XboxTLSContext ctx;
    if (!XboxTLS_CreateContext(&ctx, "consolemods.org"))
        return false;

    // Set the hash algorithm to use for certificate validation (used by both EC and RSA trust anchors).
    // Note: SHA-384 is commonly used with modern certificates (e.g., GTS Root R4, ISRG Root X1),
    //       but this can be changed to SHA-256, SHA-512, etc., depending on the CA's signature.
    ctx.hashAlgo = XboxTLS_Hash_SHA384; 

    // Step 3: Add EC trust anchor (if site uses this key type)
    if (!XboxTLS_AddTrustAnchor_EC(&ctx, EC_DN, sizeof(EC_DN), EC_Q, sizeof(EC_Q), XboxTLS_Curve_secp384r1))
        return false;

	// Step 3: Add RSA trust anchor (if site uses this key type)
	if (!XboxTLS_AddTrustAnchor_RSA(&ctx, RSA_DN, sizeof(RSA_DN), RSA_N, sizeof(RSA_N), RSA_E, sizeof(RSA_E)))
		return false;

    // Step 4: DNS resolution
    char ip[64] = { 0 };
    if (!ResolveDNS("consolemods.org", ip, sizeof(ip)))
        return false;

    // Step 5: Connect + TLS handshake
    if (!XboxTLS_Connect(&ctx, ip, "consolemods.org", 443)) {
        XboxTLS_Free(&ctx);
        return false;
    }

    // Step 6: Send GET request
    const char* path = "/wiki/Main_Page";
    char request[512];
    sprintf(request,
        "GET %s HTTP/1.1\r\n"
        "Host: consolemods.org\r\n"
        "User-Agent: Xbox360/1.0\r\n"
        "Accept: */*\r\n"
        "Connection: close\r\n\r\n", path);
    XboxTLS_Write(&ctx, request, (int)strlen(request));

    // Step 7: Read and print response
    DumpResponse(&ctx);

    // Step 8: Cleanup
    XboxTLS_Free(&ctx);
	WSACleanup();
    return true;
}
